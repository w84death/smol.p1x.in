<!DOCTYPE html>
<html>
<head>
    <title>Simple WFC</title>
    <style>
        canvas {
            border: 1px solid black;
            image-rendering: pixelated;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <button onclick="startWFC()">Generate</button>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const gridSize = 32;
        const cellSize = 10;
        const colors = ['#000000', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF'];
        
        // Define adjacency rules (what colors can be next to each other)
        const rules = {
            '#000000': ['#FFFFFF', '#FF0000'],
            '#FFFFFF': ['#000000', '#00FF00'],
            '#FF0000': ['#000000', '#0000FF'],
            '#00FF00': ['#FFFFFF', '#0000FF'],
            '#0000FF': ['#FF0000', '#00FF00']
        };

        let grid = [];

        function initializeGrid() {
            grid = [];
            for (let y = 0; y < gridSize; y++) {
                grid[y] = [];
                for (let x = 0; x < gridSize; x++) {
                    grid[y][x] = {
                        possible: [...colors],
                        collapsed: false
                    };
                }
            }
        }

        function draw() {
            canvas.width = gridSize * cellSize;
            canvas.height = gridSize * cellSize;
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (grid[y][x].collapsed) {
                        ctx.fillStyle = grid[y][x].possible[0];
                        ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }
        }

        function findLowestEntropy() {
            let lowest = [];
            let min = colors.length + 1;
            
            for (let y = 0; y < gridSize; y++) {
                for (let x = 0; x < gridSize; x++) {
                    if (!grid[y][x].collapsed && grid[y][x].possible.length < min) {
                        min = grid[y][x].possible.length;
                        lowest = [{x, y}];
                    } else if (!grid[y][x].collapsed && grid[y][x].possible.length === min) {
                        lowest.push({x, y});
                    }
                }
            }
            
            return lowest.length > 0 ? 
                lowest[Math.floor(Math.random() * lowest.length)] : 
                null;
        }

        function propagate(x, y) {
            let stack = [{x, y}];
            
            while (stack.length > 0) {
                const {x, y} = stack.pop();
                const current = grid[y][x].possible[0];
                
                // Check all neighbors
                const neighbors = [
                    {x: x-1, y}, {x: x+1, y},
                    {x, y: y-1}, {x, y: y+1}
                ].filter(n => 
                    n.x >= 0 && n.x < gridSize && 
                    n.y >= 0 && n.y < gridSize
                );

                for (const neighbor of neighbors) {
                    const cell = grid[neighbor.y][neighbor.x];
                    if (cell.collapsed) continue;
                    
                    const valid = rules[current];
                    const newPossible = cell.possible.filter(c => valid.includes(c));
                    
                    if (newPossible.length !== cell.possible.length) {
                        cell.possible = newPossible;
                        if (newPossible.length === 1) {
                            cell.collapsed = true;
                        }
                        stack.push(neighbor);
                    }
                }
            }
        }

        function startWFC() {
            initializeGrid();
            
            // Collapse first random cell
            const startX = Math.floor(Math.random() * gridSize);
            const startY = Math.floor(Math.random() * gridSize);
            grid[startY][startX].possible = [colors[Math.floor(Math.random() * colors.length)]];
            grid[startY][startX].collapsed = true;
            
            propagate(startX, startY);
            draw();
            
            function step() {
                const next = findLowestEntropy();
                if (!next) return;
                
                const cell = grid[next.y][next.x];
                cell.collapsed = true;
                cell.possible = [cell.possible[Math.floor(Math.random() * cell.possible.length)]];
                
                propagate(next.x, next.y);
                draw();
                
                requestAnimationFrame(step);
            }
            
            requestAnimationFrame(step);
        }
    </script>
</body>
</html>